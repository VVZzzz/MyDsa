#pragma once
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
#include <math.h>
//字符串匹配算法

//暴力匹配算法1
/******************************************************************************************
 * Text     :  0   1   2   .   .   .   i-j .   .   .   .   i   .   .   n-1
 *             ------------------------|-------------------|------------
 * Pattern  :                          0   .   .   .   .   j   .   .
 *                                     |-------------------|
 ******************************************************************************************/
int BruteForceMatch(char *p, char *t) {
  size_t n = strlen(t), m = strlen(p);
  int i = 0, j = 0;
  while (i < n && j < m) {
    if (t[i] == p[j]) {  //如果当前字符匹配,则共同前进
      i++;
      j++;
    } else {  //否则就重新置位j,并更新i.  注意此处更新i的依据是距离!
      j = 0;
      i = i - j + 1;
    }
  }
  return i - j; //若成功,返回的是匹配的第一个字符位置.
  //若i-j > (n-m)则查找匹配失败
  //若i-j ∈ [0,n-m]则查找成功
}

//暴力匹配算法2
/******************************************************************************************
 * Text     :  0   1   2   .   .   .   i   i+1 .   .   .   i+j .   .   n-1
 *             ------------------------|-------------------|------------
 * Pattern  :                          0   1   .   .   .   j   .   .
 *                                     |-------------------|
 ******************************************************************************************/
int BruteForceMatch2(char *p, char *t) {
  size_t n = strlen(t), m = strlen(p);
  int i = 0, j = 0;
  for (int i = 0; i < n - m + 1; i++) {  //Text从i开始
    for (int j = 0; j < m; j++) {
      if (t[i + j] != p[j]) break;  //如果不匹配,则i继续加一开始下一次匹配
    }
    if (j >= m) break;
  }
  return i;  ////若成功,返回的是匹配的第一个字符位置.
  //若 i> (n-m) 则查找匹配失败
  //若 i ∈ [0,n-m]则查找成功
}
//暴力匹配算法时间需要 O(m*(n-m)) 一般n>>m  故需要O(m*n)

/****************************************KMP算法***************************************/

//KMP算法 ---> next表
/*
 * 由于暴力匹配算法,是将模式串pattern每次后移一个字符距离,这样就导致一个问题
 * Text     :  0   1   2   .i-j .   .  Y.   .   i   .   .   n-1
 *             --------------------------------------------|------------
 * Pattern  :               0   .   .  x.   .   j   .   .
 *                          |-------------------|
 * Pattern  :                 0   .   .  x.   .   j   .   .
 *                            |-------------------|
 * Pattern  :                    0   .   .  x.   .   j   .   .
 *                               |-------------------|
 * 这样的话,文本串中的Y字符相当于要和模式串中的几乎每个字符都比较一次,这和我们分析的
 * O(n*m)一致,那么能不能不是后移一次,而是一下后移多个字符单位呢? 可以的
 * Text     :  0   1   2   .i-j .   .   i   .   .   n-1
 *             -------------|yyyyyxxxxx| |---------|------------
 * Pattern  :               0   .   .   j   .   .
 *                          |yyyyyxxxxx| |----|
 * Pattern(后移):                0   .  t   .   .   .
 *                         (j-t) |xxxxx| |--------|
 *
 * 如上图,此时P[0,j) == T[i-j,i) 即在P[j]这个地方发生失配,那么我们能否找到一个位置,
 * 使得这个模式串能后移一大截,且仍然满足模式串的不变性(即此时后移之后的模式串的前缀
 * P[0,t) == T[i-t,i) ).那么之后,我们再从模式串的t位置向后比较就完事儿了.
 *
 * 同样,我们也发现,这个位置t如何确定呢? 我们发现这个位置t要满足P[0,t) == P[j-t,j)
 * 即在模式串P[0,j)中前缀 == 后缀
 * 对任意j,考察集合: N(P,j) = { 0 <= t < j | p[0,t) == p[j-t,j) }
 * 亦即,t是在P[j]的前缀[0,j)中,所有匹配的真前缀和真后缀的长度,并且还要是最大长度!
 * 因为t越小,移动的距离越大,为了避免回溯(略过正确位置),选t最大
 *
 * 因此,一旦T[i]≠P[j],可从N(P,j)中选某个t(最大的t),令P[t]对准T[i],并继续比对.
 * 
 * 由此,我们可以知道,一个j位置对应一个t,那么我们可以预先构造一个next表,将每个位置的t都
 * 得到,这样一旦T[i]≠P[j],就得t = next[j],令P[t]对准T[i],并继续比对.
 *
 * 通配哨兵: 倘若集合N(P,j)为空集(即t=0),即模式串P[0,j)没有匹配的真前缀和真后缀该怎么保证算法
 * 顺利进行? 
 * Text     :  0   1   2   .i-j .   .   i   .   .   n-1
 *             -------------|yyyyyxxxxx| |---------|------------
 * Pattern  :               0   .   .   j   .   .
 *                          |yyyyyxxxxx| |----|
 * Pattern(后移):                0   .  t   .   .   .
 *                         (j-t) |xxxxx| |--------|
 * Pattern(N(P,j)为空):                   0   .  .   .   .   .
 *                                      *|----------------|
 *
 * 即此时我们要将模式串P后移到j+1的位置上,此时t=0
 * 我们添加一个哨兵,即next[0] = -1 , 即我们在模式串P的最开头,添加一个通配符'*'
 * 它和任意字符都匹配,这样就解决了问题,使得KMP算法能顺利进行,这也解释了为何KMP算法中
 * 判断语句首先判断j < 0
 */
//先看KMP总算法实现,在去看构造next表算法实现


//如何构造next表: 
/*
 * 我们用递推思想构造next表,即已知next[0],next[j],如何高效计算next[j+1]
 * next[j],即P[0,j)中,最大自匹配真前缀和真后缀的最大长度
 * 故: next[j+1] <= next[j] + 1 (这个可以用反证法得到)
 * 当且仅当 P[j] == P[ next[j] ]时取等号
 * 理解: 
 * Pattern  :               0   .   .   j   .   .
 *                          |yyyyyxxxxx| |----|
                                        ↑ 相等
 * Pattern      :                0   . next[j]   .   .   .
                                        ↓
 *                         (j-t) |xxxxx| |-|-------|
 *                         (j-t) |xxxxx| |-|-------|  ===>  即此时next[j+1]=next[j]+1

 * 所以当P[j]==p[ next[j] ]时,next[j+1] = next[j] + 1
 *
 * 若P[j] ≠ P[ next[j] ] , 又该如何去求next[j+1] 呢?
 * 此时我们应该依次去找P[ next[j] ] , P[ next[ next[j] ] , P[ next[ next[ next[j] ] ] ] ...
 * 直到P[next[...[...] ] ] = P[j].
 * 也就是说,next[j+1]的候选者应该是:
 * 1 + next[j]
 * 1 + next[next[j]]
 * 1 + next[next[next[j]]]
 * ...
 * 由于next[j] < j ,故该算法收敛 ,收敛于 1 + next[0] = 0
 * 
 * 理解: 
 *                  -1 0                            m
 *                  |*|----------------------------|
 *      0            j  j+1
 *      |-----------|X|-|-------|
 *        0         next[j]
 *                   ↓
 *        |---------|Y|-|---------|
 *           0      next[next[j]]
 *                   ↓
 *           |------|Z|-|------------|
 *              0   next[next[next[j]]]
 *                   ↓
 *              |---|X|-|-----------------|
 *
 * 此时 next[j+1] == 1 + next[next[next[j]]]

 */
//构造next表算法(和KMP总算法框架很像!)
int *buildNext(char *P) {  //构造模式串P的next表
  size_t m = strlen(P), j = 0;  //'主'串指针
  int *next = new int[m];
  int t = next[0] = -1;  //模式串指针
  while (j<m-1) {  //递推得到next[j+1]
    if (t < 0 || P[j] == P[t]) {  //匹配,从next[0] = -1开始
      j++;
      t++;  //长度+1,即P[j]==P[next[j]]时,next[j+1] = next[j] + 1
      next[j] = t;  //可优化
    } else {  //失配
      t = next[t];  //失配就找next[next[j]]
    }
  }
  return next;
}

//KMP总算法(其实和暴力算法1很像)
int KMPMatch(char *P, char *T) {   //KMP算法
  int *next = buildNext(P);  //构造next表
  int n = strlen(T), i = 0;  //文本串指针
  int m = strlen(P), j = 0;  //模式串指针
  while (j<m&&i<n) {         //自左向右依次比较各个字符
    if (j < 0 || T[i] == P[j]) { //若匹配，或P已移出最左侧（两个判断的次序不可交换）
      i++;
      j++;
    } else {
      j = next[j];  //模式串右移
    }
  }
  delete[] next;
  return i - j;//若成功,返回的是匹配的第一个字符位置.
  //若i-j > (n-m)则查找匹配失败
  //若i-j ∈ [0,n-m]则查找成功
}

//KMP算法时间复杂度分析
/*
 * 为O(n)
 * 我们令 k = 2*i - j 
 * 首先看KMP算法,if分支,说明匹配成功,ij同时加一,则k也加1
 * 在看else分支 , j = next[j] < j(原来) , 则k至少加1
 * 说明此时 k 就是KMP算法的上界,而对于i,它为O(n),j为O(m),
 * 又m << n , 所以可以看成常数 , 故KMP算法时间复杂度为O(n)
 *
 * 说说 k = 2*i - j的含义,首先看暴力匹配算法,i永远记录着匹配成功的字符个数
 * 故i是匹配成功的次数
 * 而 i-j , 若匹配成功,则ij同时加1,那么i-j不变且初始为0,只有匹配不成功时j = next[j]
 * 而next[j] < j , 所以i-j是匹配失败的上界
 * 故2i-j可以当作整个循环的上界
 */
//建立next表时间复杂度分析
/*
 * 实际上建表分析和KMP分析一模一样,框架都一样,故也为O(m)
 */

//建立next表优化
/*
 * 比如 文本串:  0 0 0 1 0 0 0 0 1
 * 模式串为:     0  0  0  0  1
 * 对应next表:  -1  0  1  2  3
 *
 *              0 0 0 1 0 0 0 0 1    
 *  1           0 0 0 0 1
 *  2             0 0 0 0 1
 *  3               0 0 0 0 1
 *  4                 0 0 0 0 1
 *  5                 * 0 0 0 0 1
 *
 * 实际上,2 3 4次都没有必要去比,因为后移之后的模式串这个位置不应该是0,如果是0仍然是和文本串
 * 中的1不等的, 所以这是建立next表的锅.
 * 比喻文本串中的1就是石头,模式串中的0是鸡蛋,第1次比较已经以卵击石了,后234次就不应该继续以卵击石
 * 而是一下到第5次
 * 那么如何建立一个更有效的next表,使得从1 一下子 移动到 5 呢
 *
 * 
 * 优化:  只需改一条语句 next[j] = t   , 改为:
 * next[j]  =  (p[j]!=p[t] ? t: next[t])
 * 也就是说,如果按照next表发现要替换的值p[t]仍然和p[j]相等(即仍然是鸡蛋),那么我们就不应该
 * 使next[j] = t, 而是 next[j] = next[t] ,即next[j] = next[next[j]]
 * 这样直接让下次替换上来的不在是上次的鸡蛋!
 */

/**********************************BM算法(Boyer-More算法)********************************/
/*
 * 为什么要提出BM算法,我们知道KMP算法是从模式串的第一个字符开始逐一与文本串进行比对
 * 即:  
 *  T:      | . . . x y z p . . . . . . . . . |
 *  P:            | x y z q . . |
 *
 *  即将逐一比对x y z , 直到失配.  但是当字符类很多,比如汉字,有大于5000个汉字,这样字符一一匹配成功的概率
 * 远没有失配的概率高 , 也就是说一旦从此处开始出现失配的字符,说明此处就肯定不会是整体成功匹配的开始处.
 * 即: 
 * Text     :  0   1   2   .i-j .   .  Y.   .   i   .   .   n-1
 *             --------------------------------------------|------------
 * Pattern  :               0   .   .  x.   .   j   (失配,此i-j位置排除)
 *                          |-------------------|
 * Pattern  :                 0   .   .  x.   .   j  (失配,此i-j位置排除)
 *                            |-------------------|
 * Pattern  :                    0   .   .  x.   .   j (失配,此i-j位置排除)
 *
 * 可以发现 , 我们不是去找成功匹配的对齐位置,而是去排除失配的对齐位置,因为失配的概率远远大于成功的概率.
 * 基于此,Boyer-More提出BM算法,BM算法有两个策略,一个是BadCharacter(坏字符)策略,一个是Good
 * 对比KMP算法,KMP算法是每次都找成功匹配的字符直到发生失配 , 乐于看到匹配的字符, 即我们可以认为是积累经验.
 * 而BM算法,是一旦更乐于看到失配字符,因为一旦有失配字符就可以进行下一轮比较了.我们可以认为是得到教训
 * 
 * 坏字符即发生失配的字符 , 在排除对齐位置(i-j)时,我们从模式串的最后一个字符由后向前进行匹配.
 * 为何是从后向前匹配? 
 * Text     :  0   1   2   .i-j .   .  Y.   .   i   .   .   n-1
 *             --------------------------------------------|------------
 * Pattern  :               0   .|  .  x.   . | j   (失配,此i-j位置排除)
 * Pattern  :                 0  |.   .  x.   |   j  (失配,此i-j位置排除)
 * Pattern  :                    0   .   .  x.|  .   j (失配,此i-j位置排除)
 * Pattern  :                       0   .   . |.   .   j (失配,此i-j位置排除)
 *
 * 这个图可以看出如果是从前向后找坏字符,那么只有前两次的pattern吸取到了教训,而如果是从后向前
 * 找坏字符,那么后面的更多的对齐位置的都可以吸取到教训.
 */

//BC(坏字符)策略
/*
 * 
 *                                          X
 * Text     :  0   1   2   .i   .   .   .  i+j.   .   .   .   .   n-1
 *             -------------------------------| -------------- | ------------

 *                                          Y
 * Pattern  :               0   .   .   .   j | matched suffix | (在j处失配)
 *                          |-----------------| -------------- | ------------

 * 右移模式串,使得p[j] == X
 *                                          X
 * Pattern  :                   |  0   .  | j |        'X' free       | (在j处,p[j] == X)
 *                          |---|←bc['X']→| 
 *                          shift
 * 
 * 即原本在j处发生失配 , 注意此时的后缀是已匹配的matched suffix.
 * 此时我们要右移模式串,右移距离为shift = j - bc['X']
 * 这个bc['X']即在模式串P[0,j)中等于字符'X'的位置,这实际上是和KMP算法的next表是相似道理的.
 *
 * 根据上述描述,构造bc[]表 , 有三种情况.
 * 1. P[0,m)中有多个与'X'匹配的字符,那么选哪一个呢?
 *    为避免回溯,选取shift最小的,也就是选取最靠后的那一个匹配的字符的位置
 *    但对于这种情况又有两个分支,这里先考虑若P[m+1,j)中没有与'X'匹配的字符,
 *    则就是刚才说的,简单的选取最靠后的那一个匹配的字符的位置.
 *
 * 2. P[0,j)中没有与'X'匹配的字符,且P[j+1,m)中也没有,该怎么办? 
 *    那么我们同样借助通配符哨兵,使得模式串整体后移,直到
 * Pattern  :               0   .   .   .   j | matched suffix | (在j处失配)
 *                          |-----------------| -------------- | ------------
 * Pattern  :                             | * |  0   .  . . .        'X' free       | 
 *
 * 3. 针对情况1的另一个分支,即P[m+1,j)中也出现了与'X'匹配的字符.
 *    那么此时计算shift竟然是负的,即是左移了,这显然是回溯了,故我们就简单的右移一位.
 *                                                     
 * Pattern  :               0   .   .   .   j | matched ('X') suffix | (在j处失配)
 *                          |-----------------| -------------------- | 
 * Pattern  :                0   .  . . .       |                     | (右移一位)
 *
 * 向右移动模式串之后,重新从模式串末字符开始向前进行新一轮比对
 */

//BC策略分析
/*
 * 最好情况:  
 * Text:     0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0
 * Pattern:  0 0 0 0 (发生情况2的失配)
 * Pattern:          0 0 0 0(发生情况2的失配)
 * Pattern:                  0 0 0 0(发生情况2的失配)
 * Pattern:                          0 0 0 0   (匹配成功)
 *
 * 这样的话我们只需比较O(n/m)次即可
 *
 * 最坏情况: 
 * Text:     0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0
 * Pattern:  1 0 0 0 (发生情况3的失配)
 * Pattern:  * 1 0 0 0 (发生情况3的失配)
 * Pattern:    * 1 0 0 0 (发生情况3的失配)
 * Pattern:      * 1 0 0 0 (发生情况3的失配)
 *                 ...
 * Pattern:                          1 0 0 0
 * 这样 共有O(n*m)次比对 , 显然这是很慢的
 */

//建立bc表,时间复杂度为O(字母表长度+m),可改进为O(m)
int* buildBC ( char* P ) { //构造Bad Charactor Shift表：O(m + 256)
  int *bc = new int[256];  //bc[]表,与字母表等长
  for ( size_t j = 0; j < 256; j ++ ) bc[j] = -1; //初始化：首先假设所有字符均未在P中出现
  for ( size_t m = strlen ( P ), j = 0; j < m; j ++ ) //自左向右扫描模式串P
    bc[ P[j] ] = j; //刷新P[j]的出现位置记录,只记录最新的那次.(画家算法: 后来覆盖以往)
    //即任一字符对应表项的最终取值,取决于它在模式串中出现最后的那一次.
  return bc;
}

//时间复杂度为从(O(n/m)~O(n*m))
int BM_BC_Match(char *P, char *T) {//Boyer-Morre算法(简化版，只考虑Bad Character Shift)
  int *bc = buildBC(P);  //同理,先建立BC表
  size_t n = strlen(T), i = 0;
  size_t m = strlen(T);
  while (i + m <= n) {//在到达文本串最右端前，不断右移模式串（可能不止一个字符）
    int j = m - 1; //从模式串的最后一个字符开始
    while (P[j] == T[i + j])  //自右向左开始比对
      if (--j < 0) break;
    if (j < 0)  //若极大匹配后缀 == 整个模式串，则说明已经完全匹配，故
      break;  //返回匹配位置
    else  //否则,根据BC表,右移模式串 , 使得P[bc[T[i+j]]]和T[i+j]对齐
      i += std::max(1, j - bc[T[i + j]]);
  }
  delete[] bc;
  return i; //若i+m > n则匹配失败
}

/*
 * BM算法 : GS好后缀策略
 * 如果只用BC坏字符策略
 * Text:       x x x x x C|A T C H|H A T C H x x x
 * Pattern:    C A T C H H|A T C H|(在'C'处失配 , 且发生失配情况3,右移1位)
 *                         -------
 *
 * Pattern:      C A T C H H A T C H (在'C'处失配 , 且发生失配情况3,右移1位)
 * Pattern:        C A T C H H A T C H (在'A'处失配 , 且发生失配情况1)
 *
 * Pattern:              C A T C H H A T C H (匹配成功)
 *
 * 可以发现, 中间两次移动都是1次 , 能否优化掉呢?
 * 当然是可以的,我们发现模式串后缀'ATCH'是匹配的 , 这也就引入了好后缀策略.
 *
 * 如果说坏字符BC策略是只吸取了"教训"(未匹配字符) , 那么好后缀GS策略就是"经验"(已匹配的后缀)
 * 将BC和GS策略综合起来 , 那么无疑是最好的.
 *
 * 先谈GS策略:
 * Text :      i        i+j-k       i+j              m+i       m+i+j-k         2m+i-t
 *             |          |          |                |           |               |
 *              . . . . . . . . . . .|X|-----W=U------| . . . . . . . . . . . . . . .      
 *
 *                                    j                m
 * Ptt1 :      |. . . . . . . . . . .|Y|-----好后缀U---|   (在j处失配)
 *
 *                                    k              m+k-j
 * Ptt2 :          shift  |. . . . . |*|----V(k)------|. . . . . .| (*为不等Y的字符)
 *                 shift = gs[j] = j-k
 *
 *                                                    |t
 * Ptt3 :          shift                   |---V(k)---|. . . . . . . . . . . . . .|
 *                 shift = gs[j] = m-t
 *
 * 即模式串1在j处失配 , 此时P[j+1,m) == T[i+j+1,m+i),即是好后缀U.
 * 那么根据BC策略,应该右移, 该移动多少?即shift为多少.
 *
 * 情况1: 移动到模式串2位置 , 即找到一个V(K) == 好后缀U,且P[k]!='Y'.
 * 如果有多个K满足 , 那么同样避免回溯,取k最大的那个,即和BC策略一样,取靠后那个.
 *
 * 情况2: 移动到模式串3,即如果模式串没有找到这样一个V(k) == U , 那么就应该整体后移
 * ,使得一个前缀V(k)和后缀U部分匹配,即类似于BC策略的情况2
 *
 * 我们发现shift 只与模式串有关 , 故我们可以事先得到一个gs表,这样给一个j,我们就立即得到对应的shift
 * 即gs[j]就是按照GS策略移动的距离
 */

/*
 * 构造gs[]表: 首先理解ms[j],ss[j]
 * ms[j]: P[0,j]的所有后缀中,与P某一后缀匹配的 最长者 !有可能为空
 * 注意,也就是说ms[j]这个串必须以P[j]结尾
 * 即: 
 *   0 1 2 3 4 5 6 7 8 9 10 11 12 13 14
 *   I C E D   R I C E   P  R  I  C  E
 *ss:0 0 3 0 0 0 0 0 4 0 0  0  0  0  15
 * 对于ms[8],就是"RICE"这个串了,对于ms[7],为空.
 *
 * 那么ss[j] = | ms[j] | , 即ms[j]的长度.
 * 
 * 我们一旦知道了ss[j],那么gs[j]就很容易知道了.
 *
 * 1. 若ss[j] = j+1 , 则 对于任一字符P[i](i<m-j-1) , m-j-1必是gs[i]的一个候选
 * 2. 若ss[j] <= j  , 则 对于任一字符P[m-ss[j]-1] , m-j-1必是gs[m-ss[j]-1]的一个候选
 *
 *   0                    j               m-j-1                m
 *   |                    |                |                   |      
 *   | . . MS[j] . . . . .|                |.max matchedsuffix.|
 *                        | ←          m-j-1            ->     |

 *
 *   0                    j                m-ss[j]-1           m
 *   |                    |                   |                |      
 *      | . . MS[j] . . ..|                   |.max matchedsuff|
 *                        | ←          m-j-1            ->     |
 */

int *buildSS(char *P) {//构造最大匹配后缀长度表：O(m)
  int m = strlen(P);
  int *ss = new int[m];//Suffix Size表,即ss表
  ss[m - 1] = m;  ////对最后一个字符而言，与之匹配的最长后缀就是整个P串
  //TODO: 尚未理解...
  return ss;
  
}

int *buildGS(char *P) { return buildSS(P); }

int BM_BC_GS_Match(char *P, char *T) { //完全BM算法,兼顾BC策略和GS策略
  int *bc = buildBC(P);  //创建bc[]表
  int *gs = buildGS(P);  //创建gs[]表
  size_t i = 0; //模式串相对于文本串的起始位置（初始时与文本串左对齐）
  while (i + strlen(P) < strlen(T)) {
    size_t j = strlen(P) - 1;  //从后向前比较
    while (P[j] == T[i + j])
      if (0 > --j) break;
    if (0 > j)
      break;  //此时i即为成功匹配位置
    else      //在j处发生失配 , 此时应该向右移动模式串
      i += std::max(gs[j], j - bc[T[i + j]]);  //位移量选择BC策略和GS策略的最大者
  }
  delete[] bc;
  delete[] gs;
  return i;
}

//Karp-Rabin算法
/*
 * 前面的串比较,都得需要一个一个字符的进行比较,才能知道究竟是否匹配.
 * 有没有更高效的比较方式呢?可以O(1)就可以得到是否匹配
 * 一切皆数,串也是数.
 * 如果这个串的字符全是0-9,比如:
 * Text:    5894207123084180
 * Pattern: 30834
 * 显然我们可以将Pttern 当作一个整数,进行比对,可以O(1)
 * Text:    5894207123084180
 * Pattern: 30834
 * Pattern:  30834
 * Pattern:   30834
 *
 * 那么对于传统的字符呢? 假设字符集为A-Z的26个大写字母
 * Text     : JDKSLBEIOUJ
 * Pattern  : ABC
 *
 * 一切皆数字
 * Pattern: ABC = 0 1 2(26进制) = 0*26^2 + 1*26 + 2*26^0 = 28
 * Text:    DEFGHIJKABC = 3 4 5 6 7 8 9 10 11 12 13 14 (26进制)
 * P在T中出现仅当T中某一子串与P相等 ( 为什么不是当? )
 *     DEFGHIJKABC
 *     ABC(28) =? DEF(2137)
 *      ABC(28) = ? EFG( 2840 )
 *       . . .
 *
 * 但是,如果字符集范围很大,且模式串长度也大.比如m=10,字符集范围为128 = 2^7
 * 则一个子串转换来的数需要用 7*10 = 70bit表示,这显然不能转为整数了.
 * 那么该如何办呢?
 *
 * 没错用"哈希表",即散列表,将"指纹"key(即串转换过来的数)压缩起来
 * hash(key) = key % M
 * 所以,这又导致一个问题,如果hash值相等的两个串是否一定匹配? 答案是不一定,因为不是单射关系.
 * 
 * 取M=97
 * P = 18284 , hash(P) = 48
 * T = 271828182845904523536
 *     27182  --> 22
 *      71828  --> 48 == 48,但是71828和18284是不匹配的
 *          ...
 *           18284 --> 48 == 48, 且18284==18284相等,则匹配.
 *
 * 故即使hash(key)相等 , 还不够,还要看key是否相等. 
 * 
 * 所以,此时剩下的最后一个问题就是如何计算Text中每一个字串的key了.
 * 即: Text : ABCDEFG
 *            ABC = (012)26 =  ...
 *             BCD = (123)26 = ...
 * 使用每个相邻串的相关性即可.
 */

#define M \
  97  //散列表长度：既然这里并不需要真地存储散列表，不妨取更大的素数，以降低误判的可能
#define R \
  10  //基数：对于二进制串，取2；对于十进制串，取10；对于ASCII字符串，取128或256
#define DIGIT(S, i) ((S)[i] - '0')  //取十进制串S的第i位数字值（假定S合法）
typedef __int64 HashCode;  //用64位整数实现散列码

HashCode prepareDm(size_t m) {//预处理：计算R^(m - 1) % M （仅需调用一次，不必优化）
  HashCode Dm = 1;
  //注意此处并非先计算R^(m-1)在进行对M求余,而是(R*(R*(Dm%M)%M))%M...
  for (size_t i = 1; i < m; i++) {
    Dm = (R * Dm) % M;
  }
}

bool check1by1 ( char* P, char* T, size_t i ) { //指纹相同时，逐位比对以确认是否真正匹配
   for ( size_t m = strlen ( P ), j = 0; j < m; j++, i++ ) //尽管需要O(m)时间
      if ( P[j] != T[i] ) return false; //但只要散列得当，调用本例程并返回false的概率将极低
   return true;
}

// 子串指纹快速更新算法
void updateHash ( HashCode& hashT, char* T, size_t m, size_t k, HashCode Dm ) {
   hashT = ( hashT - DIGIT ( T, k - 1 ) * Dm ) % M; //在前一指纹基础上，去除首位T[k - 1]
   hashT = ( hashT * R + DIGIT ( T, k + m - 1 ) ) % M; //添加末位T[k + m - 1]
   if ( 0 > hashT ) hashT += M; //确保散列码落在合法区间内
}

int KR_Match(char *P, char *T) { 
  size_t m = strlen(P); 
  size_t n = strlen(T);
  HashCode Dm = prepareDm(m), hashP = 0, hashT = 0;
  for (size_t i = 0; i < m; i++) {
    hashP = (hashP * R + DIGIT(P, i)) % M; //计算模式串对应的散列值
    hashT = (hashT * R + DIGIT(T, i)) % M; //计算文本串（前m位）的初始散列值
  }
  for (size_t k = 0;;) {
    if (hashT == hashP)
      if (check1by1(P, T, k)) return k; //查找成功
    
    if (++k > n - m) return k; //assert: k > n - m，表示无匹配
    else
      updateHash(hashT, T, m, k, Dm);  //否则更新hashT,即向右移动一个单位计算它的key
  }
}
